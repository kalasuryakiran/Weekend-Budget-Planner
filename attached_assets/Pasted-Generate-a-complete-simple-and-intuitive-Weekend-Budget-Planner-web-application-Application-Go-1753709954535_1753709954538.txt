Generate a complete, simple, and intuitive "Weekend Budget Planner" web application.

Application Goal:
The application helps a user plan a weekend budget (defaulting to 1000 INR) for movies, transport, and restaurant food. It should dynamically calculate and display estimated costs and the remaining budget. The core planning logic will be powered by the Google Gemini API.

Simplicity and UI Theme:
Prioritize a clean, highly responsive UI using React (functional components with hooks) and Tailwind CSS. All elements should be rounded, and the font should be "Inter". The entire application logic and UI should reside within a single React application file for maximum simplicity.

I. Frontend (React with Tailwind CSS & Google Gemini API)

Technology: React (functional components, hooks), Tailwind CSS for all styling (assume Tailwind CDN is loaded), "Inter" font, rounded elements.

Core UI Elements:

Header: A clear title like "Weekend Budget Planner" and a brief descriptive subtitle.

User Inputs:

An input field for Total Budget (INR) (default: 1000).

An input field for Number of People (default: 1).

Action Button: A prominent "Generate Plan" button. This button should display a loading spinner and be disabled during API calls.

Loading/Error/Message States: Display clear loading indicators, error messages (e.g., if API key is missing or API call fails), and success messages to the user in a non-alert fashion.

Generated Plan Display: Once a plan is generated by the LLM, display it clearly. This section should show:

Budget Summary: Initial Budget, Total Estimated Cost (from the generated plan), and Remaining Budget. The Remaining Budget should be dynamically calculated and styled (green for positive, red for negative).

Movies Section: List the suggested movie title, its fixed price (350 INR), and a simulated showtime.

Transport Section: List suggested transport methods and their estimated costs.

Food Section: List the suggested restaurant type and its estimated food cost.

Core Logic - Google Gemini API Integration:

The "Generate Plan" button will trigger a call to the Google Gemini API.

Use fetch to make the API call to https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}.

The GEMINI_API_KEY should be an empty string placeholder in the code, as per standard instructions for Canvas environment.

The prompt sent to Gemini should be structured to request a JSON object. It must explicitly state the user's initialBudget and numberOfPeople.

Prompt Requirements for Gemini:

Instruct Gemini to act as a "weekend budget planner."

Specify the initialBudget and numberOfPeople.

Request suggestions for:

Movies: Exactly 1 movie title, with each ticket costing exactly 350 INR. Include a simulated showtime (e.g., "7:00 PM").

Transport: 1-2 transport methods with estimatedCost.

Restaurants: 1 restaurant type with estimatedFoodCost.

Crucially, instruct Gemini to ensure the total estimated cost for movies, transport, and food does NOT exceed the initialBudget.

Specify the exact JSON output structure required, including movies (array of objects with title, price, showtime), transport (array of objects with method, estimatedCost), and food (array of objects with restaurantType, estimatedFoodCost).

Emphasize that only the JSON object should be returned by Gemini, with no additional text or markdown.

LLM Response Processing: Parse the JSON response from Gemini. Ensure the movie ticket price is fixed at 350 INR in the application's state, even if Gemini suggests a different price (enforce the 350 INR rule client-side).

Budget Calculation: All budget calculations (totalEstimatedCost, remainingBudget) should be performed client-side in React and update dynamically.

No Database Persistence: Crucially, the application should NOT use Firebase or any other database for saving, loading, or deleting plans. All plan generation is ephemeral and based on the current LLM call.

II. Backend (None)

There is no separate backend required for this application. All functionality (UI, LLM interaction, calculations) is handled directly within the single React frontend file.

III. Database (None)

There is no database persistence for this application. As explicitly requested, Firebase will not be used.

IV. Test Suite Configuration (Conceptual Outline for Frontend Logic)

Provide a detailed outline for how a test suite would be configured and what it would cover for this client-side React application. This should be presented in a Markdown immersive document.

Frontend Testing (React):

Frameworks: Jest, React Testing Library.

Categories:

Component Unit Tests: Verify correct rendering of UI elements, input field behavior, and button states (e.g., disabled when loading).

Logic Unit Tests: Test budget calculation logic (totalEstimatedCost, remainingBudget) with various input values.

LLM Integration Tests (Mocked): Test the generateBudgetPlan function by mocking the fetch API call to simulate Gemini's responses (including valid JSON, malformed JSON, and API errors). Verify that the component's state (e.g., generatedPlan, error, loading) updates correctly based on these mocked responses.

UI Interaction Tests: Simulate user input changes (budget, people) and button clicks ("Generate Plan"), asserting that the UI updates as expected.

General Principles: Emphasize mocking external dependencies (fetch), using clear test data, and ensuring conceptual testability of all core logic within the single file.

Output Format:

Generate the complete solution in two separate immersive blocks:

React Frontend Code (type="code", language="react")

Test Suite Configuration (type="text/markdown")